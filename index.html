<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <title>Interaktiv Keras-modell med TensorFlow.js</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 40px; background-color: #f4f4f4; }
    h1 { color: #333; }
    textarea { width: 80%; height: 100px; padding: 10px; font-size: 16px; border: 1px solid #ccc; border-radius: 5px; margin-bottom: 20px; }
    button { padding: 12px 24px; font-size: 18px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
    button:hover { background-color: #45a049; }
    #resultat { font-size: 24px; margin-top: 30px; color: #007BFF; }
    #debug { border: 1px solid #ddd; padding: 15px; margin-top: 40px; background-color: white; text-align: left; max-height: 300px; overflow-y: auto; border-radius: 5px; }
  </style>
</head>
<body>

  <h1>Interaktiv körning av din Keras-modell</h1>
  <p>Skriv in text nedan (antag att modellen är för textklassificering, t.ex. sentiment-analys). Klicka på knappen för att förutsäga.</p>

  <textarea id="inputText" placeholder="Skriv din text här..."></textarea><br>

  <button onclick="körModellen()">Ladda och kör modellen</button>

  <div id="resultat">Väntar på input...</div>

  <div id="debug">
    <strong>Debug-logg:</strong><br>
  </div>

  <!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>

  <script>
    let modell = null;
    let wordIndex = null;
    let maxLength = 100; // Ändra detta till din modells max_sequence_length från träning (t.ex. 100, hämta gärna från metadata om möjligt)
    let labels = ["Negativ", "Positiv"]; // Ändra till dina labels, t.ex. från metadata.json

    const debugDiv = document.getElementById('debug');
    function logDebug(msg) {
      debugDiv.innerHTML += msg + '<br>';
      debugDiv.scrollTop = debugDiv.scrollHeight;
    }

    async function laddaMetadata() {
      try {
        // ←←← Ändra till din GitHub-länk för metadata.json
        const response = await fetch('https://raw.githubusercontent.com/ditt-användarnamn/ditt-repo/main/tfjs_model/metadata.json');
        if (!response.ok) throw new Error('Kunde inte ladda metadata.json');
        const meta = await response.json();
        wordIndex = meta.word_index || meta vocabulary; // Antag struktur, t.ex. {word_index: {...}}
        if (meta.max_length) maxLength = meta.max_length;
        if (meta.labels) labels = meta.labels;
        logDebug('Metadata laddad framgångsrikt.');
        if (meta.createdAt) logDebug('Modell skapad: ' + meta.createdAt);
      } catch (fel) {
        logDebug('Fel vid laddning av metadata: ' + fel.message);
      }
    }

    async function körModellen() {
      const resultatDiv = document.getElementById('resultat');
      resultatDiv.innerHTML = 'Bearbetar...';
      logDebug('Startar laddning och körning...');

      try {
        if (!wordIndex) await laddaMetadata();
        if (!wordIndex) throw new Error('Word index inte laddat från metadata.');

        if (!modell) {
          logDebug('Laddar modellen... (kan ta tid första gången)');
          // ←←← Ändra till din GitHub-länk för model.json
          modell = await tf.loadLayersModel('https://raw.githubusercontent.com/ditt-användarnamn/ditt-repo/main/tfjs_model/model.json');
          logDebug('Modellen är korrekt laddad.');
          const inputShape = modell.layers[0].inputShape;
          logDebug('Input shape: ' + JSON.stringify(inputShape));
          if (modell.userDefinedMetadata && modell.userDefinedMetadata.createdAt) {
            logDebug('Modell skapad: ' + modell.userDefinedMetadata.createdAt);
          } else {
            logDebug('Skapad-datum inte tillgängligt i modellen.');
          }
        }

        // Hämta input text
        const text = document.getElementById('inputText').value.trim();
        if (!text) throw new Error('Ingen text angiven.');

        // Enkel tokenisering (antag lowercase, split på space)
        const tokens = text.toLowerCase().split(/\s+/).map(word => wordIndex[word] || 0); // 0 för okända ord
        // Padding till maxLength
        const padded = new Array(maxLength).fill(0);
        const start = Math.max(0, maxLength - tokens.length);
        for (let i = 0; i < tokens.length; i++) {
          if (i + start < maxLength) padded[i + start] = tokens[i];
        }

        // Skapa tensor [1, maxLength]
        const inputTensor = tf.tensor2d([padded], [1, maxLength]);

        // Predicera
        const output = modell.predict(inputTensor);
        const resultat = await output.data();
        const maxIndex = resultat.indexOf(Math.max(...resultat));
        resultatDiv.innerHTML = 'Förutsägelse: ' + labels[maxIndex] + ' (sannolikhet: ' + (resultat[maxIndex] * 100).toFixed(2) + '%)';

        // Städa
        inputTensor.dispose();
        output.dispose();
        logDebug('Prediktion genomförd utan fel.');

      } catch (fel) {
        resultatDiv.innerHTML = 'Något gick fel.';
        logDebug('Fel: ' + fel.message);
        console.error(fel);
      }
    }
  </script>

</body>
</html>
